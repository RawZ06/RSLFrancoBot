package fr.rawz06.rslfrancobot.api.repositories;

import com.fasterxml.jackson.databind.ObjectMapper;
import fr.rawz06.rslfrancobot.engine.domain.entities.Preset;
import fr.rawz06.rslfrancobot.engine.domain.ports.IPresetRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.io.ClassPathResource;
import org.springframework.stereotype.Repository;
import org.yaml.snakeyaml.Yaml;

import java.io.InputStream;
import java.util.*;

/**
 * Implementation of preset repository.
 * Loads presets from YAML and JSON files in resources/data.
 */
@Repository
public class YamlPresetRepository implements IPresetRepository {

    private static final Logger logger = LoggerFactory.getLogger(YamlPresetRepository.class);
    private final Map<String, Preset> presets = new HashMap<>();
    private final ObjectMapper objectMapper;

    public YamlPresetRepository(ObjectMapper objectMapper) {
        this.objectMapper = objectMapper;
        loadPresets();
    }

    private void loadPresets() {
        try {
            loadFrancoPreset();
            loadRSLPreset();
            loadPoTPreset();
            logger.info("Presets loaded successfully: {}", presets.keySet());
        } catch (Exception e) {
            logger.error("Error loading presets", e);
        }
    }

    private void loadFrancoPreset() throws Exception {
        // Load base JSON file
        Map<String, Object> baseSettings = loadJsonFile("data/franco.json");

        // Load options from YAML
        List<Preset.PresetOption> options = loadFrancoOptionsFromYaml();

        Preset francoPreset = new Preset("franco", baseSettings, options);
        presets.put("franco", francoPreset);
    }

    private void loadRSLPreset() {
        // For RSL, we also use franco.json as base
        // but without configurable options (generated by Python)
        try {
            Map<String, Object> baseSettings = loadJsonFile("data/franco.json");
            Preset rslPreset = new Preset("rsl", baseSettings, List.of());
            presets.put("rsl", rslPreset);
        } catch (Exception e) {
            logger.error("Error loading RSL preset", e);
        }
    }

    private void loadPoTPreset() {
        // For PoT, similar to RSL
        try {
            Map<String, Object> baseSettings = loadJsonFile("data/franco.json");
            Preset potPreset = new Preset("pot", baseSettings, List.of());
            presets.put("pot", potPreset);
        } catch (Exception e) {
            logger.error("Error loading PoT preset", e);
        }
    }

    @SuppressWarnings("unchecked")
    private List<Preset.PresetOption> loadFrancoOptionsFromYaml() throws Exception {
        Yaml yaml = new Yaml();
        List<Preset.PresetOption> options = new ArrayList<>();

        try (InputStream inputStream = new ClassPathResource("data/franco.yaml").getInputStream()) {
            Map<String, Map<String, Object>> yamlData = yaml.load(inputStream);

            for (Map.Entry<String, Map<String, Object>> entry : yamlData.entrySet()) {
                String optionId = entry.getKey();
                Map<String, Object> optionData = entry.getValue();

                String label = (String) optionData.get("label");
                String description = (String) optionData.get("description");
                Map<String, Object> settingsToApply = (Map<String, Object>) optionData.get("settings");

                // Handle incompatibilities
                List<String> incompatibleWith = detectIncompatibilities(optionId);

                Preset.PresetOption option = new Preset.PresetOption(
                        optionId,
                        label,
                        description,
                        settingsToApply,
                        incompatibleWith
                );

                options.add(option);
            }
        }

        return options;
    }

    /**
     * Detects incompatibilities between options.
     * Based on legacy SettingParser logic.
     */
    private List<String> detectIncompatibilities(String optionId) {
        // List of known incompatibilities
        Map<String, List<String>> incompatibilitiesMap = Map.ofEntries(
                Map.entry("keysy", List.of("keysanity_all", "keyring_all", "keyring_regional")),
                Map.entry("keysanity_all", List.of("keysy", "keyring_all", "keyring_regional")),
                Map.entry("keyring_all", List.of("keysy", "keysanity_all", "keyring_regional")),
                Map.entry("keyring_regional", List.of("keysy", "keysanity_all", "keyring_all")),
                Map.entry("token_dj", List.of("token_ow", "token_all")),
                Map.entry("token_ow", List.of("token_dj", "token_all")),
                Map.entry("token_all", List.of("token_dj", "token_ow")),
                Map.entry("songsanity", List.of("songsanity_dungeon")),
                Map.entry("songsanity_dungeon", List.of("songsanity")),
                Map.entry("dungeon_er", List.of("dungeon_er_mixed")),
                Map.entry("dungeon_er_mixed", List.of("dungeon_er")),
                Map.entry("boss_souls", List.of("regional_souls", "souls")),
                Map.entry("regional_souls", List.of("boss_souls", "souls")),
                Map.entry("souls", List.of("boss_souls", "regional_souls")),
                Map.entry("minimal", List.of("scarce")),
                Map.entry("scarce", List.of("minimal")),
                // All bridge options are mutually incompatible
                Map.entry("bridge_6_med", List.of("bridge_4_med_bgk_6_med", "bridge_4_med_bgk_6_dj", "bridge_5_med_bgk_6_med", "bridge_5_med_bgk_6_dj", "bridge_1_stone", "bridge_2_stones", "bridge_3_stones", "bridge_vanilla", "bridge_5_dj", "bridge_6_dj", "bridge_7_dj", "bridge_8_dj", "bridge_9_dj")),
                Map.entry("bridge_4_med_bgk_6_med", List.of("bridge_6_med", "bridge_4_med_bgk_6_dj", "bridge_5_med_bgk_6_med", "bridge_5_med_bgk_6_dj", "bridge_1_stone", "bridge_2_stones", "bridge_3_stones", "bridge_vanilla", "bridge_5_dj", "bridge_6_dj", "bridge_7_dj", "bridge_8_dj", "bridge_9_dj")),
                Map.entry("bridge_4_med_bgk_6_dj", List.of("bridge_6_med", "bridge_4_med_bgk_6_med", "bridge_5_med_bgk_6_med", "bridge_5_med_bgk_6_dj", "bridge_1_stone", "bridge_2_stones", "bridge_3_stones", "bridge_vanilla", "bridge_5_dj", "bridge_6_dj", "bridge_7_dj", "bridge_8_dj", "bridge_9_dj")),
                Map.entry("precompleted_1", List.of("precompleted_2", "precompleted_3")),
                Map.entry("precompleted_2", List.of("precompleted_1", "precompleted_3")),
                Map.entry("precompleted_3", List.of("precompleted_1", "precompleted_2"))
        );

        return incompatibilitiesMap.getOrDefault(optionId, List.of());
    }

    @SuppressWarnings("unchecked")
    private Map<String, Object> loadJsonFile(String path) throws Exception {
        try (InputStream inputStream = new ClassPathResource(path).getInputStream()) {
            return objectMapper.readValue(inputStream, Map.class);
        }
    }

    @Override
    public Optional<Preset> getPreset(String name) {
        return Optional.ofNullable(presets.get(name.toLowerCase()));
    }

    @Override
    public boolean presetExists(String name) {
        return presets.containsKey(name.toLowerCase());
    }
}
